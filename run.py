#!/usr/bin/env python
"""
Abstract: Simple application hub, intended to be used in combination with Docker for Linux.
Author:   Robert Voelckner
Date:     Oct. 2020
"""
import platform
import psutil
from typing import List, Union, Tuple
import subprocess
import shlex
import os
import signal
from datetime import datetime
import logging
from threading import Event
import time
import sys
import argparse
from configparser import ConfigParser


logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

FORMATTER = logging.Formatter("%(asctime)s - %(levelname)s - %(name)s - %(filename)s::%(funcName)s - line %(lineno)s - %(message)s")
LOG_HANDLER = logging.StreamHandler(sys.stdout)
LOG_HANDLER.setLevel(logging.DEBUG)
LOG_HANDLER.setFormatter(FORMATTER)
LOG_HANDLER.setLevel(logging.DEBUG)
logger.addHandler(LOG_HANDLER)

# Some textual definitions
DEFAULT_PROCFILE = os.path.splitext(os.path.basename(__file__))[0] + ".ini"
SECTION_RUN = "RUN"
SECTION_RUN_ONCE = "RUN_ONCE"
SECTION_TERMINATE_AND_RUN = "TERMINATE_AND_RUN"

# Signal stuff
SHUTDOWN_EVENT = Event()  # Will be set if the machine sends SIGTERM/SIGINT signal
SIGTERM_TIMEOUT = 9.0
SIGNAL_NAME = {signal.SIGINT: "SIGINT", signal.SIGTERM: "SIGTERM"}
PYTHON_SIGINT_HANDLER = signal.getsignal(signal.SIGINT)
PYTHON_SIGTERM_HANDLER = signal.getsignal(signal.SIGTERM)


def split_commandline(commandline: str) -> Tuple[str, List[str]]:
    args = shlex.split(commandline)
    if len(args) == 1:
        return args[0], []
    else:
        return args[0], args[1:]


def is_suitable_process(commandline: str, process_executable: str, process_args: List[str]) -> bool:
    """
    Little helper function that decides if a process has been created from a certain commandline.

    :param commandline: Commandline string that the process might have been created with.
    :param process_executable: Path + Name of the process executable
    :param process_args: Additional args of the process
    :return: Returns if the process was created using the given commandline.
    """
    cmd_executable, cmd_args = split_commandline(commandline)
    if "/" in cmd_executable and "/" in process_executable:
        cmd_executable__path = os.path.dirname(os.path.abspath(cmd_executable))
        process_executable__path = os.path.dirname(os.path.abspath(process_executable))
        if cmd_executable__path != process_executable__path:
            return False
    cmd_executable__basename = os.path.basename(cmd_executable)
    process_executable__basename = os.path.basename(process_executable)
    if cmd_executable__basename.startswith(process_executable__basename) or process_executable__basename.startswith(cmd_executable__basename):
        if all(arg in process_args for arg in cmd_args):
            return True
    return False


def get_process_pids(commandlines: Union[str, List[str]], exclude_process_handles: List = None) -> List[int]:
    """
    Returns the PIDs of multiple processes.

    :param commandlines: Commandline strings of the processes whose PIDs we want to determine.
    :param exclude_process_handles: If not None, this may contain a list process handles (generated by subprocess.Popen). In this case, these processes' PIDs will be excluded from returned PIDs list.
    :return: Returns a list of PIDs.
    """
    if not isinstance(commandlines, List):
        commandlines = [commandlines]
    pids = set()
    for commandline in commandlines:
        for process_ in psutil.process_iter(attrs=["pid", "cmdline", "name"]):
            proc_args = process_.cmdline()
            proc_exe = process_.name()
            proc_pid = process_.pid
            if proc_pid != 1 and process_.status() != "zombie" and is_suitable_process(commandline, process_executable=proc_exe, process_args=proc_args):
                pids.add(proc_pid)
    if exclude_process_handles:
        exclude_pids = set([handle.pid for handle in exclude_process_handles])
        pids = pids.difference(exclude_pids)
    return list(pids)


def term_processes(commandlines: Union[str, List[str]], sigterm_timeout: float = None, process_handles: List = None) -> None:
    """
    Kills process(es). Prior to that - if desired - the processes are sent SIGTERM.

    :param commandlines: Commandline strings of processes to terminate. List may be empty.
    :param sigterm_timeout: If not None, the processes will be sent SIGTERM prior to kill. Contains the timeout (seconds) as float.
    :param process_handles: If not None, this may contain a list process handles (generated by subprocess.Popen). These processes will be killed as well.
    :return:
    """
    if not isinstance(commandlines, List):
        commandlines = [commandlines]
    if not process_handles:
        process_handles = []
    process_handles = [handle for handle in process_handles if handle.poll() is None]  # Filters out those handles whose processes have already been terminated

    commandlines_pids = get_process_pids(commandlines, exclude_process_handles=process_handles)
    if not len(commandlines_pids) and len(process_handles) == 0:
        logger.info("There are no processes to be terminated")
        return
    logger.info(f"Terminating {len(commandlines_pids)+len(process_handles)} process(es):  {commandlines_pids} + {len(process_handles)} handles")
    if sigterm_timeout:
        logger.info(f"Sending SIGTERM..")
        for pid in commandlines_pids:
            try:
                os.kill(pid, signal.SIGTERM)
            except ProcessLookupError:
                pass
        for handle in process_handles:
            handle.send_signal(signal.SIGTERM)
        started_at = datetime.now()
        while (len(commandlines_pids) or len(process_handles)) and (datetime.now()-started_at).total_seconds() < sigterm_timeout:
            time.sleep(0.2)
            commandlines_pids = get_process_pids(commandlines, exclude_process_handles=process_handles)
            process_handles = [handle for handle in process_handles if handle.poll() is None]
        if len(commandlines_pids) or len(process_handles):
            logger.info(f"SIGTERM timed out after {sigterm_timeout}s. {len(commandlines_pids)+len(process_handles)} processes are still alive")
        else:
            logger.info(f"Successfully terminated all processes using SIGTERM (after {round((datetime.now()-started_at).total_seconds(), 1)}s)")
    if len(commandlines_pids) or len(process_handles):
        for pid in commandlines_pids:
            try:
                os.kill(pid, signal.SIGKILL)
            except ProcessLookupError:
                pass
        for handle in process_handles:
            handle.send_signal(signal.SIGKILL)
        logger.info(f"Successfully sent KILL to {len(commandlines_pids)+len(process_handles)} processes")


def run_processes_in_background(run: List[str], run_once: List[str], terminate_and_run: List[str]) -> List:
    """Runs commands as new processes. Returns Popen handles."""

    n_processes = len(run + run_once + terminate_and_run)
    if not n_processes:
        logger.info("There are no processes to be run")
        return []
    else:
        logger.info(f"Starting to run {n_processes} process(es)")
    term_processes(terminate_and_run, sigterm_timeout=SIGTERM_TIMEOUT)
    handles = []

    def Popen(cmd: str) -> None:
        if "|" not in cmd:
            handle = subprocess.Popen(shlex.split(cmd), start_new_session=True)
        else:
            handle = subprocess.Popen(cmd, start_new_session=True, shell=True)
        handles.append(handle)

    for cmd in run:
        Popen(cmd)
    for cmd in run_once + terminate_and_run:
        if len(get_process_pids(cmd)):
            logger.info(f"'{cmd}' already runs. Skipping")
            continue
        Popen(cmd)
    logger.info(f"Successfully started {len(handles)} process(es)")
    return handles


def __handle_signal(sig, frame):
    SHUTDOWN_EVENT.set()
    logger.info(f"Received {SIGNAL_NAME[sig]}. 'Shutdown' flag is now set. Termination of process follows shortly.")
    # Re-install original Python signal handlers
    signal.signal(signal.SIGTERM, PYTHON_SIGTERM_HANDLER)
    signal.signal(signal.SIGINT, PYTHON_SIGINT_HANDLER)


def parse_procfile(ini_file_name: str, run: List[str], run_once: List[str], terminate_and_run: List[str]):
    """Parses a given Proc-File and adds the read commandline strings to the provided lists."""
    logger.info(f"Starting to parse procfile {ini_file_name}.")
    if not os.path.exists(ini_file_name):
        # print(f"Given procfile '{ini_file_name}' does not exist. Exiting now.")
        logger.error(f"Given procfile '{ini_file_name}' does not exist. Exiting now.")
        sys.exit(-1)
    parser = ConfigParser(delimiters="\n", allow_no_value=True)
    parser.read(ini_file_name)
    config = {}
    sections = [(SECTION_RUN, run), (SECTION_RUN_ONCE, run_once), (SECTION_TERMINATE_AND_RUN, terminate_and_run)]
    n = 0
    for pair in sections:
        section_name = pair[0]
        dest_list = pair[1]
        if parser.has_section(section_name):
            params = parser.items(section_name)
            params = [tple[0] for tple in params]
            for param in params:
                param = param.strip()
                if param not in dest_list:
                    dest_list.append(param)
                    n += 1
    logger.info(f"Successfully parsed procfile. Read {n} entries and added them to the respective processes lists.")


if __name__ == '__main__':
    if platform.system().lower() != "linux":
        print("This script is intended only to be run on Linux. Exiting now.")
        exit(-1)

    print(" ".join(sys.argv))

    parser = argparse.ArgumentParser(description="Runs multiple processes and, if desired, terminates them again. "
                                                 "Processes may be long-running applications, as well as complex shell "
                                                 "commands.")
    parser.add_argument("--run", "-r", type=str, action="append", metavar="COMMAND", dest="run",
                        help="Runs a process, regardless if it already runs.")
    parser.add_argument("--run-once", "-r-once", type=str, action="append", metavar="COMMAND", dest="run_once",
                        help="Runs an application, but only if it doesn't run yet.")
    parser.add_argument("--terminate-and-run", "-r-term", type=str, action="append", metavar="COMMAND", dest="terminate_and_run",
                        help="Before running the application, terminate all other instances of it. Makes use of "
                             "SIGTERM and (after a timeout) KILL.")
    parser.add_argument("--block", action="store_true", dest="block",
                        help="Block after starting the applications. When receiving SIGTERM/SIGINT, forward SIGTERM to "
                             "applications.")
    # parser.add_argument("--nohup", action="store_true",
    #                     help="Use nohup to make applications persist after log-off.")
    parser.add_argument("--ignore-procfile", action="store_true", dest="ignore_procfile",
                        help="Don't make use of any .ini procfile! Process config is taken from commandline, only.")
    parser.add_argument("procfile", default=DEFAULT_PROCFILE, type=str, metavar="PROCFILE", nargs="?",
                        help=f"Default: {DEFAULT_PROCFILE}; .ini file that lists the processes to start. Valid "
                             f"sections are [{SECTION_RUN}], [{SECTION_RUN_ONCE}] and [{SECTION_TERMINATE_AND_RUN}].")
    args = parser.parse_args()
    logger.debug(args)

    # Get processes lists
    PROCESSES_RUN = args.run if args.run else []
    PROCESSES_RUN_ONCE = args.run_once if args.run_once else []
    PROCESSES_TERMINATE_AND_RUN = args.terminate_and_run if args.terminate_and_run else []

    # Parse .ini file, if necessary
    if not args.ignore_procfile:
        parse_procfile(args.procfile, PROCESSES_RUN, PROCESSES_RUN_ONCE, PROCESSES_TERMINATE_AND_RUN)

    logger.debug(f"..\nrun = {PROCESSES_RUN}\nrun_once = {PROCESSES_RUN_ONCE}\nterminate_and_run = {PROCESSES_TERMINATE_AND_RUN}")

    # Start our processes
    process_handles = run_processes_in_background(run=PROCESSES_RUN, run_once=PROCESSES_RUN_ONCE, terminate_and_run=PROCESSES_TERMINATE_AND_RUN)

    if args.block:
        logger.info("Blocking now undefinitely until receiving SIGTERM")
        signal.signal(signal.SIGTERM, __handle_signal)
        signal.signal(signal.SIGINT, __handle_signal)
        while not SHUTDOWN_EVENT.isSet():
            SHUTDOWN_EVENT.wait(timeout=1)
            # From time to time, read the return values of our started applications to prevent zombie processes
            non_null = [handle.poll() is not None for handle in process_handles]
            if any(non_null):
                logger.info(f"{sum(non_null)} process(es) exited..")
                process_handles = [handle for handle in process_handles if handle.poll() is None]

        term_processes(commandlines=PROCESSES_RUN + PROCESSES_RUN_ONCE + PROCESSES_TERMINATE_AND_RUN,
                       sigterm_timeout=SIGTERM_TIMEOUT, process_handles=process_handles)

    sys.exit(0)
